##API CALL ON GEMINI-2.0-flash

import json
import requests
from helper_functions import read_entire_file, clear_file, prompt_generator, append_from_file, write_to_file
from acl_analyzer import compare_acl
def gemini_api_call(abac_rules_generated, acl_file, attribute_data_file, attribute_description_file):
    #Parameters
        #llm_abac_rules_generated: the file where you want to save the llm generated abac rules to
        # acl_file: the acl file to feed to the LLM
        # attribute_data_file: file with all user and resource information
        # attribute_description_file the description of the attributes listed above.


    #clear the file to write over
    clear_file(abac_rules_generated)

    key_file ="llm-research/keys/geminiKey.txt"
    
    print("\nCalling gemini API...\n")

    try:
        gemini_key = read_entire_file(key_file)

    except FileNotFoundError as e:
        print(f"Error reading file: {e}")
        return
    except Exception as e:
        print(f"Unexpected read error: {e}")
        return
    
 #declare the location on the complete request being made
    complete_request_file = "llm-research/complete-prompt.txt"
    
    #generate the prompt
    prompt_generator(acl_file, attribute_data_file, attribute_description_file, complete_request_file)
    
    #pass prompt request from a .txt file to a string obj (required for the request)
    complete_request = read_entire_file("llm-research/complete-prompt.txt")

    # send to Gemini 
    url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"
    headers = {"Content-Type": "application/json", "X-goog-api-key": gemini_key}
    data = {
        "contents": [
            {
                "parts": [
                    {"text": complete_request}
                ]
            }
        ]
    }

    try:
        resp = requests.post(url, headers=headers, json=data)
        resp.raise_for_status()
    except requests.exceptions.Timeout:
        print("HTTP error: request timed out")
        return
    except requests.exceptions.RequestException as e:
        print(f"HTTP error: {e}")
        return

    try:
        payload = resp.json()
    except json.JSONDecodeError:
        print("Response was not valid JSON.")
        return


    text = (
        payload.get("candidates", [{}])[0]
            .get("content", {})
            .get("parts", [{}])[0]
            .get("text", "")
    )

    #output the abac rules to a file for testing
    with open(abac_rules_generated, "w", encoding="utf-8") as of:
        of.write(text)
 
# def itter_gemini_call(is_match, ttl,abac_rules_generated, acl_file, complete_request_file ):
#     # is_match is false if the ACLs are not a 100% match
#     # ttl is time to live for how many itterations we want to allow
#     # abac_rules_generated is the file to save the LLM response of ABAC rules
#     # acl_file is the Original ACL file, generated by our set of rules
#     # complete_request_file complete request file being sent to the LLM
#         #in this funciton it will be the re-requested file
    
#     print("Recalling gemini API")

#     counter = 1
   
#     #TODO: add the new request to the complete request
    
#     append_from_file(complete_request_file, "llm-research/complete-prompt.txt")
#     append_from_file(complete_request_file, "llm-research/re-request.txt")


#     while ( counter < ttl):

#     #TODO: add text to segment the info being sent 
#         if is_match == True:
#             print("100% match has been found")
#             return
        
#         else:
#             print(f"Re-calling gemini API \n Itteration number: {counter}\n")

#             write_to_file(complete_request_file, "THESE ARE THE RULES GENERATED BY YOU (THE LLM)")
#             #TODO: add the rules that the LLM generated 
#             append_from_file(complete_request_file, abac_rules_generated)
            
#             write_to_file(complete_request_file, "THIS IS THE ACL GENERATED BY YOUR ABAC RULES")
#             #TODO add the ACL generated by the rules
#             append_from_file(complete_request_file, "llm-research/llm-generated-data/gemini/gemini-healthcare/gemini-ACL.txt")
            
#             write_to_file(complete_request_file, "THESE ARE SOME NUMBERS GENERATED BY THE ACL COMPARISON")

#             #TODO: add the analytics that the comparison of the ACLs generated
#             temp_string, is_match = compare_acl(acl_file, "llm-research/llm-generated-data/gemini/gemini-healthcare/gemini-ACL.txt")
#             write_to_file(complete_request_file, temp_string)
#            #TODO: request the prompt again

#             clear_file(abac_rules_generated)

#             key_file ="llm-research/keys/geminiKey.txt"
            
#             print("\nCalling gemini API...\n")

#             try:
#                 gemini_key = read_entire_file(key_file)

#             except FileNotFoundError as e:
#                 print(f"Error reading file: {e}")
#                 return
#             except Exception as e:
#                 print(f"Unexpected read error: {e}")
#                 return
            
#         #declare the location on the complete request being made            
            
#             #pass prompt request from a .txt file to a string obj (required for the request)
#             complete_request = read_entire_file(complete_request_file)
            
#             # send to Gemini 
#             url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"
#             headers = {"Content-Type": "application/json", "X-goog-api-key": gemini_key}
#             data = {
#                 "contents": [
#                     {
#                         "parts": [
#                             {"text": complete_request}
#                         ]
#                     }
#                 ]
#             }

#             try:
#                 resp = requests.post(url, headers=headers, json=data)
#                 resp.raise_for_status()
#             except requests.exceptions.Timeout:
#                 print("HTTP error: request timed out")
#                 return
#             except requests.exceptions.RequestException as e:
#                 print(f"HTTP error: {e}")
#                 return

#             try:
#                 payload = resp.json()
#             except json.JSONDecodeError:
#                 print("Response was not valid JSON.")
#                 return


#             text = (
#                 payload.get("candidates", [{}])[0]
#                     .get("content", {})
#                     .get("parts", [{}])[0]
#                     .get("text", "")
#             )

#             #output the abac rules to a file for testing
#             with open(abac_rules_generated, "w", encoding="utf-8") as of:
#                 of.write(text)


#         counter +=1

if __name__ == "__main__":
    gemini_api_call()
    print ("api call finalized")


##CURRENT ISSUE:M ACL NOT BEING GENERATED BY LLM REQUEST